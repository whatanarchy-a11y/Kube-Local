# WSL + PowerShell + Docker + Kubernetes 치트시트

> 목적: **WSL(리눅스)** + **PowerShell(윈도우)**에서 네트워크 점검/설정, 그리고
> **Docker / Kubernetes(kubectl)** 운영 시 자주 쓰는 명령어를
> **실행 예시 + 출력 형태**로 빠르게 참고합니다.

- 날짜: 2026-01-10
- 주의: 출력은 **환경(네트워크, 권한, OS, 클러스터 구성)**에 따라 달라집니다.
  아래는 **형태를 익히는 샘플**입니다.

---

## WSL 초기 설정 (예시)

Windows PowerShell:

```powershell
wsl --install
wsl --set-default-version 2
wsl -l -v
```

WSL(Ubuntu)에서 systemd 활성화:

```bash
sudo tee /etc/wsl.conf >/dev/null <<'EOF'
[boot]
systemd=true
EOF

sudo apt update
sudo apt -y upgrade
```

설정 반영 후 WSL 재시작:

```powershell
wsl --shutdown
wsl -d Ubuntu
```

WSL에서 상태 확인:

```bash
systemctl is-system-running
```

---

## 0) 빠른 목차

- [1. PowerShell 네트워크](#1-powershell-네트워크)
- [2. WSL(리눅스) 네트워크](#2-wsl리눅스-네트워크)
- [3. Docker](#3-docker)
- [4. Kubernetes(kubectl)](#4-kuberneteskubectl)
- [5. 실전 트러블슈팅 체크리스트](#5-실전-트러블슈팅-체크리스트)
- [6. 원샷 점검 스니펫](#6-원샷-점검-스니펫)

---

## 1) PowerShell 네트워크

### 1-1) IP / NIC / 게이트웨이 / DNS 확인

```powershell
ipconfig /all
```

예시 출력(일부):
```text
Ethernet adapter 이더넷:
   IPv4 Address. . . . . . . . . . . : 192.168.0.10
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.0.1
   DNS Servers . . . . . . . . . . . : 1.1.1.1
                                       8.8.8.8
```

```powershell
Get-NetIPConfiguration
```

예시:
```text
InterfaceAlias : 이더넷
IPv4Address    : 192.168.0.10
IPv4DefaultGateway : 192.168.0.1
DNSServer      : {1.1.1.1, 8.8.8.8}
```

---

### 1-2) DNS 조회 / 검증

```powershell
nslookup naver.com
```

예시:
```text
Server:  one.one.one.one
Address: 1.1.1.1

Non-authoritative answer:
Name:    naver.com
Addresses: 223.130.195.200
           223.130.195.95
```

```powershell
Resolve-DnsName naver.com
```

예시:
```text
Name      Type TTL Section IPAddress
----      ---- --- ------- ---------
naver.com A    60  Answer  223.130.195.200
```

---

### 1-3) 연결성 테스트 (ICMP / TCP 포트)

```powershell
ping 8.8.8.8
```

예시:
```text
Reply from 8.8.8.8: bytes=32 time=35ms TTL=115
```

```powershell
Test-NetConnection naver.com -Port 443
```

예시:
```text
ComputerName     : naver.com
RemoteAddress    : 223.130.195.200
RemotePort       : 443
TcpTestSucceeded : True
```

---

### 1-4) 경로/라우팅 확인

```powershell
tracert naver.com
```

예시:
```text
  1  192.168.0.1  2 ms
  2  10.10.0.1    5 ms
  3  ...
```

```powershell
route print
```

예시(일부):
```text
IPv4 Route Table
Network Destination        Netmask          Gateway       Interface  Metric
0.0.0.0                    0.0.0.0          192.168.0.1   192.168.0.10  25
```

---

### 1-5) 열려있는 포트 / 연결 상태 / PID 매핑

```powershell
netstat -ano
```

예시(일부):
```text
TCP  0.0.0.0:80     0.0.0.0:0   LISTENING   1234
TCP  127.0.0.1:5432 0.0.0.0:0   LISTENING   5678
```

```powershell
Get-NetTCPConnection -State Listen |
  Select LocalAddress,LocalPort,OwningProcess |
  Sort LocalPort
```

예시:
```text
LocalAddress LocalPort OwningProcess
----------- --------- -------------
0.0.0.0     80        1234
127.0.0.1   5432      5678
```

PID → 프로세스:
```powershell
Get-Process -Id 1234
```

예시:
```text
Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
    260      18    45000      90000       1.23   1234   1 nginx
```

---

### 1-6) 방화벽 상태 / 규칙 확인·추가

```powershell
Get-NetFirewallProfile
```

예시:
```text
Name    Enabled DefaultInboundAction DefaultOutboundAction
----    ------- -------------------- ---------------------
Domain  True    Block                Allow
Private True    Block                Allow
Public  True    Block                Allow
```

포트(예: 8080) 인바운드 허용 규칙 추가:
```powershell
New-NetFirewallRule -DisplayName "Allow 8080" -Direction Inbound -Action Allow -Protocol TCP -LocalPort 8080
```

예시:
```text
Name        : {GUID...}
DisplayName : Allow 8080
Enabled     : True
```

---

## 2) WSL(리눅스) 네트워크

### 2-1) IP / 라우팅 / DNS

```bash
ip a
```

예시:
```text
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> ...
    inet 172.24.155.12/20 brd 172.24.159.255 scope global eth0
```

```bash
ip route
```

예시:
```text
default via 172.24.144.1 dev eth0
172.24.144.0/20 dev eth0 proto kernel scope link src 172.24.155.12
```

```bash
cat /etc/resolv.conf
```

예시:
```text
nameserver 172.24.144.1
```

---

### 2-2) 연결성 테스트 (HTTP/TLS/TCP)

```bash
ping -c 3 8.8.8.8
```

예시:
```text
3 packets transmitted, 3 received, 0% packet loss
```

```bash
curl -I https://naver.com
```

예시:
```text
HTTP/2 200
server: NWS
```

TCP 포트 체크:
```bash
nc -vz naver.com 443
```

예시:
```text
Connection to naver.com 443 port [tcp/https] succeeded!
```

대체(내장 TCP):
```bash
timeout 2 bash -c 'cat < /dev/null > /dev/tcp/naver.com/443' && echo OK || echo FAIL
```

예시:
```text
OK
```

---

### 2-3) 리스닝 포트 / 프로세스 확인

```bash
ss -lntp
```

예시:
```text
LISTEN 0 4096 0.0.0.0:8000 0.0.0.0:* users:(("python",pid=2201,fd=3))
```

```bash
lsof -i :8000
```

예시:
```text
python 2201 user  3u  IPv4  ... TCP *:8000 (LISTEN)
```

---

### 2-4) 방화벽(ubuntu 기준)

```bash
sudo ufw status
```

예시:
```text
Status: active
To                         Action      From
22/tcp                     ALLOW       Anywhere
```

포트 허용:
```bash
sudo ufw allow 8080/tcp
```

---

## 3) Docker

### 3-1) 상태/버전

```bash
docker version
docker info
```

예시(일부):
```text
Server: Docker Engine - Community
 Kernel Version: 5.15.x
 Operating System: Docker Desktop
```

---

### 3-2) 이미지

```bash
docker images
```

예시:
```text
REPOSITORY   TAG     IMAGE ID       CREATED        SIZE
nginx        latest  ca871a86d45a   2 weeks ago    228MB
```

```bash
docker pull redis:7
```

예시:
```text
7: Pulling from library/redis
Status: Downloaded newer image for redis:7
```

---

### 3-3) 컨테이너 실행/조회/로그/exec

```bash
docker run -d --name web -p 8080:80 nginx:latest
```

예시:
```text
a1b2c3d4e5f6...
```

```bash
docker ps
```

예시:
```text
CONTAINER ID  IMAGE       COMMAND                  STATUS         PORTS                  NAMES
a1b2c3d4e5f6  nginx:latest "nginx -g 'daemon off'" Up 10 seconds  0.0.0.0:8080->80/tcp   web
```

```bash
docker logs -f web
```

예시:
```text
2026/01/10 01:02:03 [notice] 1#1: start worker processes
```

```bash
docker exec -it web bash
```

예시:
```text
root@a1b2c3d4e5f6:/#
```

---

### 3-4) 네트워크 / 볼륨

```bash
docker network ls
docker network inspect bridge
```

```bash
docker volume ls
docker volume create pgdata
```

예시:
```text
pgdata
```

---

### 3-5) 정리(종료/삭제/정리)

```bash
docker stop web
docker rm web
docker rmi nginx:latest
docker system df
docker system prune -a
```

---

## 4) Kubernetes(kubectl)

### 4-1) 클러스터/컨텍스트

```bash
kubectl version --client
kubectl config get-contexts
kubectl config current-context
kubectl cluster-info
```

예시:
```text
Kubernetes control plane is running at https://127.0.0.1:6443
CoreDNS is running at https://127.0.0.1:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy
```

---

### 4-2) 리소스 조회(가장 많이 씀)

```bash
kubectl get nodes -o wide
kubectl get ns
kubectl get pods -A
kubectl get svc -A
kubectl get deploy -n default
```

예시:
```text
NAME   STATUS   ROLES           AGE   VERSION
cp1    Ready    control-plane   10d   v1.30.2

NAMESPACE  NAME                    READY  STATUS   RESTARTS  AGE
default    api-5f6b7c8d9f-2kq7m   1/1    Running  0         2m
```

---

### 4-3) describe / events (문제 파악 핵심)

```bash
kubectl describe pod api-5f6b7c8d9f-2kq7m -n default
kubectl get events -A --sort-by=.metadata.creationTimestamp
```

예시(일부):
```text
Events:
  Type    Reason     Age   From               Message
  Normal  Scheduled  2m    default-scheduler  Successfully assigned default/api... to cp1
  Normal  Pulled     2m    kubelet            Container image "myapi:1.0" already present
```

---

### 4-4) 로그 / exec / 포트포워딩

```bash
kubectl logs -n default api-5f6b7c8d9f-2kq7m
kubectl logs -f -n default api-5f6b7c8d9f-2kq7m
```

예시:
```text
INFO  Server started on :8080
```

```bash
kubectl exec -it -n default api-5f6b7c8d9f-2kq7m -- sh
```

예시:
```text
/ # ls
app  bin  etc  ...
```

```bash
kubectl port-forward -n default svc/api 18080:80
```

예시:
```text
Forwarding from 127.0.0.1:18080 -> 80
```

---

### 4-5) 배포/롤아웃/롤백

```bash
kubectl apply -f deployment.yaml
kubectl rollout status deploy/api -n default
kubectl rollout history deploy/api -n default
kubectl rollout undo deploy/api -n default
```

예시:
```text
deployment.apps/api configured
deployment "api" successfully rolled out
```

---

## 5) 실전 트러블슈팅 체크리스트

### 5-1) “포트가 진짜 열렸나?” (로컬/WSL/컨테이너/Pod)

**Windows**
```powershell
Test-NetConnection 127.0.0.1 -Port 8080
netstat -ano | findstr :8080
```

**WSL**
```bash
ss -lntp | grep ':8080'
curl -I http://127.0.0.1:8080
```

**Docker**
```bash
docker ps
docker port web
docker logs web
```

**K8s**
```bash
kubectl get pod -o wide
kubectl logs <pod> -n <ns>
kubectl port-forward -n <ns> svc/<svc> 18080:80
```

---

### 5-2) “Pod는 Running인데 서비스가 안 붙는다”

```bash
kubectl get svc -n default
kubectl describe svc api -n default
kubectl get endpoints api -n default
kubectl get pod -n default -o wide
```

확인 포인트:
- Service selector가 Pod label과 매칭되는지
- endpoints가 비어있지 않은지
- targetPort/containerPort가 일치하는지

---

### 5-3) “이미지 Pull 안됨 (ErrImagePull / ImagePullBackOff)”

```bash
kubectl describe pod <pod> -n <ns>
```

Events에서:
- `ErrImagePull`, `ImagePullBackOff`
- 레지스트리 인증 필요하면 imagePullSecret
- 태그 오타/아키텍처 불일치(amd64/arm64)도 빈번

---

## 6) 원샷 점검 스니펫

### 6-1) PowerShell: 네트워크 요약 + 포트 리스닝 요약

```powershell
Write-Host "== IP CONFIG ==" -ForegroundColor Cyan
Get-NetIPConfiguration | Format-List

Write-Host "== DNS TEST ==" -ForegroundColor Cyan
Resolve-DnsName naver.com | Select-Object -First 3 | Format-Table

Write-Host "== ROUTES (default) ==" -ForegroundColor Cyan
route print | Select-String "0.0.0.0"

Write-Host "== LISTEN PORTS (Top 20) ==" -ForegroundColor Cyan
Get-NetTCPConnection -State Listen |
  Select LocalAddress,LocalPort,OwningProcess |
  Sort LocalPort |
  Select -First 20 | Format-Table
```

---

### 6-2) WSL: IP/Route/DNS/Listen/Curl 한 번에

```bash
echo "== ip a =="; ip a | sed -n '1,80p'
echo
echo "== ip route =="; ip route
echo
echo "== resolv.conf =="; cat /etc/resolv.conf
echo
echo "== listen ss =="; ss -lntp | head -n 20
echo
echo "== curl https =="; curl -I https://naver.com | head -n 10
```

---

## 참고: 자주 쓰는 “정리” 구문

- Docker 전체 정리(주의: 이미지/캐시 싹 지움)
  ```bash
  docker system prune -a
  ```
- K8s 네임스페이스 전체 Pod 보기
  ```bash
  kubectl get pods -A
  ```
- 특정 워크로드만 필터링
  ```bash
  kubectl get pod -A | grep api
  ```

---

원하면 다음 버전으로 확장해서 **“내 환경 기준(WSL2 + Docker Desktop + kind/minikube/k3s)”**으로  
포트/라우팅/프록시/인그레스/서비스 타입(NodePort/LoadBalancer)까지 포함해 더 구체적인 케이스도 정리할 수 있습니다.
