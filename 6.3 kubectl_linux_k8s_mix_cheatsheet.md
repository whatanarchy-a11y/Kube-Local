## kubectl + Linux 혼합 명령어 치트시트 (현장 패턴 정리)

> **핵심 요약**
- `kubectl ...`로 시작하면 **Kubernetes API(클러스터 리소스)**를 조회/조작하는 흐름이 시작됩니다.
- `kubectl exec POD -- <cmd>`에서 `--` **뒤의 `<cmd>`는 Linux 명령이지만 “컨테이너(파드) 내부”**에서 실행됩니다.
- `| grep/awk/sed/sort/head/tail`, `$()`, 변수(`POD=...`)가 보이면 **Linux 쉘이 kubectl 출력(텍스트)을 가공** 중입니다.

---

## 1) “대상(리소스)”로 먼저 구분하기

### A. Linux 명령어(호스트/로컬 OS 대상)
```
`ls`, `cd`, `grep`, `awk`, `sed`, `tail`, `journalctl`, `systemctl`, `ps`, `curl`, `ssh`
```

---

# Linux 명령어 정리: `ls`, `cd`, `grep`, `awk`, `sed`, `tail`, `journalctl`, `systemctl`, `ps`, `curl`, `ssh`

> 목적: 현장에서 **자주 쓰는 리눅스 기본 명령어 11개**를 “무엇을 하는지 / 옵션 / 실전 예시 / 자주 하는 실수” 중심으로 정리했습니다.  
> 각 명령어는 `man <command>` 로 더 깊게 확인할 수 있습니다.

---

## 1) `ls` — 디렉터리/파일 목록 보기

### 하는 일
- 현재(또는 지정한) 디렉터리의 파일/디렉터리 목록을 출력합니다.

### 자주 쓰는 옵션
- `-l` : 자세히(권한/소유자/크기/시간)
- `-a` : 숨김 파일 포함(`.`로 시작)
- `-h` : 사람이 읽기 쉬운 크기(주로 `-l`과 함께)
- `-t` : 수정 시간 기준 정렬(최신 먼저)
- `-r` : 정렬 역순
- `-S` : 파일 크기 기준 정렬
- `-R` : 하위 디렉터리 재귀
- `--color=auto` : 타입별 색상 표시(배포판 기본 적용 많음)

### 실전 예시
```bash
ls
ls -l
ls -alh
ls -lt | head
ls -lhS
ls -al --time-style=long-iso
ls -R ./logs
```

### 팁/주의
- `ls -l`의 첫 글자: `d`(directory), `-`(file), `l`(symlink)
- 파일명에 공백이 있으면 파이프라인에서 예상과 다르게 처리될 수 있어 주의(스크립트에서는 `find -print0` + `xargs -0` 추천).

---

## 2) `cd` — 작업 디렉터리 이동

### 하는 일
- 현재 쉘의 작업 디렉터리를 변경합니다(프로세스 내부 상태 변화).

### 자주 쓰는 패턴
- `cd` : 홈 디렉터리로 이동
- `cd -` : 직전 디렉터리로 이동
- `cd ..` : 상위 디렉터리
- `cd ~user` : 특정 사용자 홈으로 이동(권한/존재 여부에 따라 실패 가능)

### 실전 예시
```bash
cd /var/log
cd ..
cd ~
cd -
cd ~/projects/myapp
```

### 팁/주의
- 스크립트에서 `cd` 실패 시 이후 명령이 엉뚱한 경로에서 실행될 수 있음 → `set -e` 또는 `cd ... || exit 1` 습관화.
- `pwd`로 현재 위치 확인.

---

## 3) `grep` — 텍스트 검색(라인 단위 매칭)

### 하는 일
- 파일/표준입력에서 **패턴(정규식/문자열)**을 찾아 매칭되는 줄을 출력합니다.

### 자주 쓰는 옵션
- `-n` : 라인 번호 표시
- `-i` : 대소문자 무시
- `-r` / `-R` : 디렉터리 재귀 검색(`-R`은 심볼릭 링크도 따라감)
- `-E` : 확장 정규식(Egrep 스타일) 사용
- `-F` : 정규식이 아닌 “고정 문자열”로 검색(빠르고 안전)
- `-v` : 매칭되지 않는 줄 출력(반전)
- `-w` : 단어 단위 매칭
- `-o` : 매칭된 부분만 출력
- `-C 3` / `-A 3` / `-B 3` : 문맥 출력(앞뒤 줄)
- `--line-buffered` : 파이프에서 즉시 출력(실시간 로그에서 유용)

### 실전 예시
```bash
# 파일에서 에러 라인 찾기
grep -n "ERROR" app.log

# 여러 파일에서 대소문자 무시 검색
grep -Rin "timeout" ./configs

# 정규식(확장)로 여러 패턴
grep -E "ERROR|WARN" app.log

# 고정 문자열로 안전 검색(정규식 특수문자 포함될 때)
grep -F "[INFO]" app.log

# 특정 단어만(예: "cat"이 "catch"에 걸리지 않도록)
grep -w "cat" words.txt

# 제외(노이즈 제거)
grep -v "healthcheck" access.log
```

### 팁/주의
- `[` `.` `*` `?` 같은 문자가 포함된 검색어는 기본적으로 정규식으로 해석됨 → 그냥 찾고 싶으면 `-F` 사용.
- 바이너리 파일/권한 문제로 에러가 나면 `2>/dev/null`로 stderr를 별도 처리할 수 있음.

---

## 4) `awk` — 텍스트 처리(필드 기반)

### 하는 일
- 줄을 읽어 **필드(기본 공백 구분)**로 나누고, 조건/연산/출력을 수행하는 강력한 텍스트 처리기입니다.

### 핵심 개념
- `$0` : 전체 줄
- `$1`, `$2`, … : 1번째/2번째 필드
- `FS` : 입력 필드 구분자(기본 공백), `-F`로 지정 가능
- `NR` : 현재 레코드(줄) 번호
- `NF` : 현재 줄의 필드 개수
- `BEGIN {}` : 처리 시작 전 1회 실행
- `{}` : 각 줄마다 실행
- `END {}` : 처리 종료 후 1회 실행

### 실전 예시
```bash
# 1) 특정 컬럼 출력
awk '{print $1, $3}' file.txt

# 2) 콤마 CSV에서 2번째 필드만
awk -F, '{print $2}' data.csv

# 3) 조건 필터링(3번째 컬럼이 500 이상)
awk '$3 >= 500 {print}' metrics.txt

# 4) 합계/평균
awk '{sum += $3} END {print "sum=", sum, "avg=", sum/NR}' metrics.txt

# 5) 헤더 출력 + 서식 지정
awk 'BEGIN{printf "%-20s %s\n", "USER", "PID"} {printf "%-20s %s\n", $1, $2}' ps.out
```

### 팁/주의
- 공백이 “연속 공백”이어도 기본 FS는 잘 처리하지만, 탭/다른 구분자면 `-F '\t'` 또는 `-F:` 등 명시.
- 복잡해지면 스크립트 파일로 분리(`awk -f script.awk input`).

---

## 5) `sed` — 스트림 편집기(치환/삭제/추출)

### 하는 일
- 입력 스트림을 받아 **라인 단위로 편집**(치환, 삭제, 특정 줄만 출력 등)합니다.

### 자주 쓰는 옵션/명령
- `s/OLD/NEW/` : 치환
- `g` : 한 줄에서 전체 치환(기본은 첫 번째만)
- `-n` : 기본 출력 끄고 `p` 명령으로 필요한 것만 출력
- `p` : 출력(print)
- `d` : 삭제(delete)
- `-i` : 파일을 직접 수정(in-place)  
  - GNU sed: `-i` 가능, macOS(BSD sed): `-i ''` 필요

### 실전 예시
```bash
# 1) 한 줄에서 첫 매칭만 치환
sed 's/http/https/' urls.txt

# 2) 한 줄에서 전체 치환
sed 's/http/https/g' urls.txt

# 3) 특정 줄 범위만 출력(10~20줄)
sed -n '10,20p' file.txt

# 4) 특정 패턴 포함 줄 삭제
sed '/DEBUG/d' app.log

# 5) 파일 직접 수정(주의!)
sed -i 's/old_value/new_value/g' config.ini
```

### 팁/주의
- `/`가 포함된 문자열(경로 등) 치환 시 구분자를 바꾸면 편함:
```bash
sed 's|/var/www|/srv/www|g' paths.txt
```
- `-i`는 되돌리기 어렵습니다 → 백업 옵션(`-i.bak`) 사용 권장:
```bash
sed -i.bak 's/foo/bar/g' file.txt
```

---

## 6) `tail` — 파일 끝부분 보기/실시간 팔로우

### 하는 일
- 파일의 마지막 N줄을 출력하거나, 로그를 **실시간으로 따라가며(follow)** 출력합니다.

### 자주 쓰는 옵션
- `-n 200` : 마지막 200줄
- `-f` : 추가되는 내용을 계속 출력
- `-F` : `-f` + 파일 교체(로그 로테이션)에도 계속 추적
- `--pid=<PID>` : 해당 PID가 종료되면 tail도 종료(GNU coreutils)

### 실전 예시
```bash
tail -n 50 /var/log/syslog
tail -f /var/log/nginx/access.log
tail -F /var/log/nginx/access.log

# 실시간 tail + 필터(버퍼링 주의)
tail -F app.log | grep --line-buffered -i error
```

### 팁/주의
- 로그 로테이션이 있는 파일은 보통 `-F`가 안전합니다.
- `tail -f`는 끊을 때 `Ctrl + C`.

---

## 7) `journalctl` — systemd 저널 로그 조회

### 하는 일
- systemd 기반 시스템에서 **저널(journald)** 로그를 조회합니다.

### 자주 쓰는 옵션
- `-u <unit>` : 특정 서비스(unit)만 보기
- `-b` : 부팅 기준(현재 부팅)
- `-k` : 커널 로그만
- `-f` : 실시간 follow
- `-n 200` : 마지막 200줄
- `--since "2026-01-24 09:00"` / `--until ...` : 시간 범위
- `-p err` : 우선순위 필터(예: `emerg|alert|crit|err|warning|notice|info|debug`)
- `-o cat` : 포맷 간소화(메시지 본문 위주)
- `--no-pager` : 페이저(less) 없이 출력

### 실전 예시
```bash
# 전체 로그(최근)
journalctl -n 200 --no-pager

# 특정 서비스(k3s, nginx, docker 등)
journalctl -u k3s -n 200 --no-pager
journalctl -u ssh -n 200 --no-pager

# 부팅 이후 로그
journalctl -b -n 200

# 오늘 오전 9시 이후의 에러만
journalctl --since "today 09:00" -p err --no-pager

# 실시간 모니터링
journalctl -u k3s -f
```

### 팁/주의
- 권한이 필요할 수 있습니다: `sudo journalctl ...`
- 저널 보관 정책은 `/etc/systemd/journald.conf`에 의해 달라집니다(디스크 제한/영구 보관 등).

---

## 8) `systemctl` — systemd 서비스/유닛 관리

### 하는 일
- systemd의 유닛(서비스, 타이머, 소켓 등)을 조회/시작/중지/재시작/자동실행 설정합니다.

### 자주 쓰는 명령
- 상태 확인: `systemctl status <unit>`
- 시작/중지/재시작: `start|stop|restart`
- 설정 다시 읽기: `daemon-reload` (유닛 파일 수정 후)
- 자동 시작: `enable|disable`
- 부팅 시 즉시 적용 포함: `enable --now`
- 전체 유닛 보기: `systemctl list-units --type=service`
- 실패한 것만: `systemctl --failed`

### 실전 예시
```bash
# 상태 확인
systemctl status k3s
systemctl status nginx

# 재시작
sudo systemctl restart nginx

# 부팅 시 자동 시작 설정 + 즉시 시작
sudo systemctl enable --now docker

# 유닛 파일 수정 후 반영
sudo systemctl daemon-reload
sudo systemctl restart myapp.service

# 실패한 서비스 확인
systemctl --failed
```

### 팁/주의
- 서비스명은 보통 `nginx.service`인데 `.service`는 생략 가능.
- “실행 중인데 로그가 없다” → `journalctl -u <unit>`로 함께 확인.

---

## 9) `ps` — 프로세스 목록/상태 확인

### 하는 일
- 현재 시스템에서 실행 중인 프로세스 정보를 출력합니다.

### 자주 쓰는 옵션/조합
- `ps aux` : BSD 스타일 전체 목록(리눅스에서 흔히 사용)
- `ps -ef` : SysV 스타일 전체 목록(리눅스에서 흔히 사용)
- `ps -p <pid> -o ...` : 특정 PID의 원하는 컬럼만 출력
- `--sort=-%cpu` : CPU 사용량으로 정렬(내림차순)

### 컬럼 자주 보는 것
- `PID` : 프로세스 ID
- `%CPU`, `%MEM` : 사용률
- `RSS` : 실제 메모리 사용(Resident Set Size)
- `STAT` : 상태(예: `R` 실행, `S` 슬립, `D` I/O 대기, `Z` 좀비)
- `COMMAND` : 실행 명령

### 실전 예시
```bash
# 전체 목록
ps aux | head
ps -ef | head

# 특정 프로세스 찾기(패턴 검색)
ps aux | grep -i nginx

# CPU 많이 쓰는 순
ps aux --sort=-%cpu | head

# 특정 PID 상세
ps -p 1234 -o pid,ppid,user,%cpu,%mem,etime,cmd
```

### 팁/주의
- `ps aux | grep nginx`는 grep 프로세스 자신도 걸릴 수 있음:
```bash
ps aux | grep -i '[n]ginx'
```

---

## 10) `curl` — HTTP(S) 요청/테스트/다운로드

### 하는 일
- URL로 요청을 보내고 응답을 출력/저장하는 도구(REST API 테스트에도 매우 흔함).

### 자주 쓰는 옵션
- `-I` : 헤더만(HEAD 요청)
- `-i` : 응답 헤더 + 바디 함께 출력
- `-v` : 상세 로그(디버깅)
- `-sS` : 조용히(`-s`) 하되 에러는 표시(`-S`)
- `-L` : 리다이렉트 따라가기
- `-o file` : 파일로 저장
- `-O` : 원래 파일명으로 저장
- `-X METHOD` : HTTP 메서드 지정(GET/POST/PUT/DELETE…)
- `-H` : 헤더 추가
- `-d` : 바디 데이터 전송(POST/PUT 등에 사용)
- `--connect-timeout`, `--max-time` : 타임아웃

### 실전 예시
```bash
# 단순 GET
curl http://example.com

# 헤더만 보기
curl -I https://example.com

# JSON API 호출(헤더 + 바디)
curl -sS -H "Accept: application/json" https://api.example.com/health | jq .

# POST JSON
curl -sS -X POST https://api.example.com/items \
  -H "Content-Type: application/json" \
  -d '{"name":"apple","qty":3}'

# 파일 다운로드
curl -L -o file.zip https://example.com/file.zip

# 연결/응답 타임아웃
curl --connect-timeout 3 --max-time 10 https://example.com
```

### 팁/주의
- HTTPS 인증서 문제 테스트(임시): `-k`(보안상 위험, 개발/검증용으로만)
- API 디버깅은 `-v`가 유용하지만 민감정보(토큰 등)가 노출될 수 있으니 주의.

---

## 11) `ssh` — 원격 서버 접속/명령 실행/포트 포워딩

### 하는 일
- 안전한 채널로 원격 서버에 접속하거나 원격 명령을 실행합니다(SCP/SFTP와 함께 사용 빈도 높음).

### 자주 쓰는 옵션
- `user@host` : 접속 대상(사용자 생략 시 현재 사용자)
- `-p <port>` : 포트 지정(기본 22)
- `-i <keyfile>` : 개인키 지정
- `-o ...` : 옵션 직접 지정(예: StrictHostKeyChecking)
- `-L local:host:remote` : 로컬 포트 포워딩(로컬 → 원격)
- `-R remote:host:local` : 리버스 포워딩(원격 → 로컬)
- `-J jump` : 점프 호스트(바스천) 경유
- `-T` : pseudo-tty 비활성(스크립트용)
- `-t` : tty 강제(원격에서 상호작용 명령 필요할 때)

### 실전 예시
```bash
# 기본 접속
ssh ubuntu@192.168.56.10

# 포트 지정
ssh -p 2222 ubuntu@host

# 키 파일 지정
ssh -i ~/.ssh/id_ed25519 ubuntu@host

# 원격에서 명령 1회 실행
ssh ubuntu@host "uname -a && df -h"

# 로컬 포트 포워딩(로컬 8080 -> 원격 127.0.0.1:80)
ssh -L 8080:127.0.0.1:80 ubuntu@host

# 점프 호스트(바스천) 경유
ssh -J ubuntu@bastion ubuntu@private-host
```

### 팁/주의
- “REMOTE HOST IDENTIFICATION HAS CHANGED!” 경고는 **호스트키가 바뀌었거나 MITM 가능성**을 의미 → 확실히 서버 재설치 등으로 변경된 것이 맞을 때만 `known_hosts` 정리.
- 서버마다 옵션을 고정하려면 `~/.ssh/config` 사용:
```sshconfig
Host mylab
  HostName 192.168.56.10
  User ubuntu
  IdentityFile ~/.ssh/id_ed25519
  Port 22
```

---

# 빠른 치트시트(현장 조합)

```bash
# 최근 에러 로그 빠르게 보기(시스템 서비스)
sudo journalctl -u nginx -n 200 --no-pager | grep -i error

# 실시간 로그 + 키워드 필터
sudo journalctl -u k3s -f | grep --line-buffered -i "warn\|error"

# 특정 프로세스/포트 디버깅(프로세스 찾기)
ps aux | grep -i '[n]ginx'

# HTTP 헬스체크
curl -sS -I http://localhost:8080

# SSH로 원격에서 로그 조회
ssh ubuntu@host "sudo journalctl -u k3s -n 100 --no-pager"
```

---

## 참고
- 각 명령의 상세 옵션: `man ls`, `man grep`, `man awk`, `man sed`, `man tail`, `man journalctl`, `man systemctl`, `man ps`, `man curl`, `man ssh`
- 도움말: `command --help` (예: `grep --help`)

---

### B. Kubernetes 명령어(k8s API 대상)
`kubectl get/describe/logs/exec/apply/delete/top ...`
- **클러스터 리소스(Pod/Service/Deployment/Node 등)**를 다룸  
- `kubectl`은 결국 **API Server에 요청**을 보냅니다.

### C. 컨테이너 안(Linux이지만 Pod 내부) 대상
예: `kubectl exec POD -- ls /var/log`
- `exec` 뒤의 명령은 **Pod 내부 Linux**
- 헷갈리기 쉬운 포인트: **명령은 Linux인데, 실행 “대상”이 Pod 내부**
---
```
ubuntu@w2:~$ kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
my-first-pod             1/1     Running   0          5h19m
nginx-66686b6766-7x2d9   1/1     Running   0          21d
nginx-66686b6766-d4xtt   1/1     Running   0          14d
nginx-66686b6766-frj65   1/1     Running   0          13d
whoami-b85fc56b4-fk6p4   1/1     Running   0          13d

ubuntu@w2:~$ kubectl exec my-first-pod -- ls /var/log
apt
btmp
dpkg.log
faillog
lastlog
nginx
wtmp
```

---

## 2) 가장 흔한 혼합 패턴: “kubectl 출력”을 Linux 파이프로 가공

### 예시 A) Running Pod만 보기
```sh
kubectl get pods -n demo | grep Running
```
- **k8s:** `kubectl get pods -n demo`
- **Linux:** `| grep Running`
- 의미: k8s에서 목록을 가져오고 → Linux 도구로 텍스트 필터링

### 예시 B) 특정 컬럼만 뽑기
```sh
kubectl get pods -n demo -o wide | awk '{print $1, $6, $7}'
```
- **k8s:** `kubectl get ...`
- **Linux:** `awk ...`
- 의미: “가져오기(k8s)” + “가공(Linux 텍스트 처리)”

> **팁:** 가능하면 `-o jsonpath=...` / `-o go-template=...`처럼 **kubectl 출력 옵션으로 구조적으로 뽑는 방식이 더 안전**합니다.

---

## 3) “호스트 Linux” vs “Pod 내부 Linux” 섞어 쓰기

### 예시 C) 호스트에서 실행(내 서버)
```sh
tail -n 50 /var/log/syslog
```
- **전부 Linux(호스트)**

### 예시 D) Pod 안에서 실행(컨테이너 내부 Linux)
```sh
kubectl exec -n demo mypod -- tail -n 50 /var/log/nginx/access.log
```
- **k8s:** `kubectl exec -n demo mypod --`
- **Linux(컨테이너 내부):** `tail -n 50 ...`

> **구분 포인트:** `kubectl exec POD --` 뒤는 Linux 명령이지만 **호스트가 아니라 Pod 내부**에서 실행됩니다.

---

## 4) “kubectl 결과를 변수로 받아” Linux 흐름에서 재사용

### 예시 E) 첫 번째 Pod 이름을 가져와서 로그 보기
```sh
POD=$(kubectl get pods -n demo -l app=nginx -o jsonpath='{.items[0].metadata.name}')
kubectl logs -n demo "$POD" | tail -n 50
```
- **Linux:** `POD=$( ... )` (쉘 변수/커맨드 치환)
- **k8s:** `kubectl get ...`
- **k8s:** `kubectl logs ...`
- **Linux:** `| tail -n 50`

---

## 5) “리소스 상태 파악 + 원인 분석” 혼합 대표 흐름

### 예시 F) CrashLoopBackOff Pod 찾고, 이벤트/로그 확인
```sh
kubectl get pods -n demo | egrep 'CrashLoopBackOff|Error'
kubectl describe pod -n demo <pod-name> | less
kubectl logs -n demo <pod-name> --previous | tail -n 100
```
- **k8s:** `kubectl get/describe/logs`
- **Linux:** `egrep`, `less`, `tail`
- 의미: k8s 정보 수집 후 → Linux 도구로 읽기/검색/요약

---

## 6) Node(리눅스) 문제와 Pod 문제를 같이 볼 때

### 예시 G) Node 상태 확인(k8s) + 노드 OS 로그 보기(Linux)
```sh
kubectl get nodes -o wide
kubectl describe node <node-name> | egrep 'Conditions|Ready|Pressure'
ssh <node-ip> "sudo journalctl -u kubelet -n 200 --no-pager"
```
- **k8s:** `kubectl get/describe`
- **Linux:** `egrep`
- **Linux(노드 OS):** `ssh ... journalctl ...`
- 의미: “클러스터 관점(k8s)”과 “노드 OS 관점(Linux)”을 교차 확인

---

## 7) 헷갈림 방지용 3줄 규칙

1. `kubectl`이 앞에 오면 **k8s 리소스 조회/조작**이 시작된다.  
2. `--` 뒤에 오는 명령은 **컨테이너 내부 Linux 명령**이다.  
3. `|`, `grep/awk/sed`, `$()`가 보이면 **Linux 쉘이 kubectl 출력(텍스트)을 가공** 중이다.

---

# 작업 흐름별 “혼합 명령어 세트” (Cheat Sheet)

아래는 현장에서 특히 많이 쓰는 4개 시나리오를 기준으로, **kubectl(K8s) + Linux(쉘/텍스트/네트워크)**가 섞인 형태로 정리했습니다.

---

## 1) Pod 장애 분석 (CrashLoop, ImagePull, OOM, Pending 등)

### 1-1. 이상 Pod 빠르게 찾기
```sh
kubectl get pod -A | egrep 'CrashLoopBackOff|Error|ImagePullBackOff|Pending|Evicted'
```
- **k8s:** `kubectl get pod -A`
- **Linux:** `egrep ...`

### 1-2. 이벤트/원인(스케줄링, 이미지, 볼륨 등) 확인
```sh
kubectl describe pod -n demo mypod | egrep -n 'Events|Warning|Failed|Back-off|OOM|Pull'
```
- **k8s:** `describe`
- **Linux:** `egrep -n`

### 1-3. 로그 확인(현재/이전 컨테이너)
```sh
kubectl logs -n demo mypod --tail=200
kubectl logs -n demo mypod --previous --tail=200 | tail -n 50
```
- **k8s:** `logs`
- **Linux:** `tail`(후처리)

### 1-4. Pod 내부에서 프로세스/파일 확인(컨테이너 내부 Linux)
```sh
kubectl exec -n demo mypod -- sh -lc "ps aux | head"
kubectl exec -n demo mypod -- sh -lc "ls -al /app && df -h"
```
- **k8s:** `exec ... --`
- **Linux(컨테이너 내부):** `ps/ls/df/head`

### 1-5. 리소스/메모리 압박(OOM) 의심 시(top + 정렬)
```sh
kubectl top pod -n demo | sort -k3 -hr | head
```
- **k8s:** `top pod`
- **Linux:** `sort/head`

### 1-6. 노드 레벨 확인(노드 상태 + kubelet 로그)
```sh
kubectl get node -o wide
kubectl describe node <node> | egrep -n 'Ready|Pressure|Disk|Memory|PID|Events'
ssh <node-ip> "sudo journalctl -u kubelet -n 200 --no-pager | tail -n 80"
```
- **k8s:** node 조회/describe
- **Linux:** `egrep`, `ssh/journalctl/tail`

---

## 2) 서비스 라우팅 확인 (Service/Endpoints/DNS/NetworkPolicy 포함)

### 2-1. Service/Endpoints가 실제로 붙었는지
```sh
kubectl get svc,ep -n demo -o wide
kubectl get ep -n demo my-svc -o yaml | egrep -n 'subsets|addresses|ports'
```
- **k8s:** `get svc,ep`, `get ep -o yaml`
- **Linux:** `egrep`

> **Endpoints가 비어있으면** 높은 확률로 `selector ↔ pod label` 불일치입니다.

### 2-2. selector/label 매칭 검증
```sh
kubectl get svc -n demo my-svc -o jsonpath='{.spec.selector}'; echo
kubectl get pod -n demo --show-labels | grep app=
```
- **k8s:** `jsonpath` 출력, pod 조회
- **Linux:** `echo`, `grep`

### 2-3. 클러스터 내부에서 curl로 라우팅 테스트(임시 디버그 Pod)
```sh
kubectl run -n demo tmp --rm -it --image=curlimages/curl -- sh
# (Pod 안에서)
curl -sS http://my-svc:8080/health | head
```
- **k8s:** `kubectl run ...`
- **Linux(컨테이너 내부):** `sh/curl/head`

### 2-4. DNS 확인(CoreDNS)
```sh
kubectl run -n demo dns --rm -it --image=busybox:1.36 -- sh
# (Pod 안에서)
nslookup my-svc
nslookup my-svc.demo.svc.cluster.local
```
- **k8s:** `kubectl run ...`
- **Linux(컨테이너 내부):** `nslookup`

### 2-5. NetworkPolicy 의심 시(정책/적용 범위)
```sh
kubectl get netpol -A
kubectl describe netpol -n demo <name> | egrep -n 'podSelector|ingress|egress|policyTypes'
```
- **k8s:** `get/describe netpol`
- **Linux:** `egrep`

---

## 3) HPA/리소스 튜닝 (requests/limits, metrics, scale 동작 확인)

### 3-1. HPA 상태/이벤트 확인
```sh
kubectl get hpa -n demo
kubectl describe hpa -n demo my-hpa | egrep -n 'Metrics|Current|Target|Events|Failed'
```
- **k8s:** `get/describe hpa`
- **Linux:** `egrep`

### 3-2. Pod/Node 리소스 실측(top) + 정렬
```sh
kubectl top pod -n demo | sort -k3 -hr | head
kubectl top node | sort -k3 -hr | head
```
- **k8s:** `top`
- **Linux:** `sort/head`

### 3-3. requests/limits 확인(Deployment → Pod 템플릿)
```sh
kubectl get deploy -n demo myapp -o yaml | egrep -n 'resources:|requests:|limits:'
```
- **k8s:** `get deploy -o yaml`
- **Linux:** `egrep`

### 3-4. HPA가 안 움직일 때(대표 원인 점검)
#### (a) metrics-server 없음/오류
```sh
kubectl get deploy -n kube-system | grep metrics
kubectl logs -n kube-system deploy/metrics-server --tail=200 | egrep -i 'error|fail|x509|timeout'
```
- **k8s:** `get/logs`
- **Linux:** `grep/egrep`

#### (b) requests 미설정(특히 CPU 기반 HPA)
```sh
kubectl get pod -n demo -o jsonpath='{range .items[*]}{.metadata.name}{"	"}{.spec.containers[0].resources.requests.cpu}{"
"}{end}'
```
- **k8s:** `jsonpath`로 구조적으로 추출(가장 안전)

### 3-5. 부하를 줘서 스케일 테스트(임시 load generator)
```sh
kubectl run -n demo load --rm -it --image=busybox:1.36 -- sh -lc "while true; do wget -qO- http://my-svc:8080/ >/dev/null; done"
```
- **k8s:** `kubectl run ...`
- **Linux(컨테이너 내부):** `sh/while/wget`

---

## 4) Ingress/로드밸런서 확인 (Ingress Controller, LB, TLS, 라우팅)

### 4-1. Ingress 기본 확인
```sh
kubectl get ingress -A
kubectl describe ingress -n demo my-ing | egrep -n 'Rules|Host|Path|Backend|TLS|Events'
```
- **k8s:** ingress 조회/describe
- **Linux:** `egrep`

### 4-2. Ingress Controller 상태/로그(NGINX 기준)
```sh
kubectl get pod -n ingress-nginx -o wide
kubectl logs -n ingress-nginx deploy/ingress-nginx-controller --tail=200 | egrep -i 'error|warn|upstream|ssl|timeout'
```
- **k8s:** `get/logs`
- **Linux:** `egrep -i`

### 4-3. LoadBalancer EXTERNAL-IP 할당 여부
```sh
kubectl get svc -A | grep LoadBalancer
kubectl describe svc -n ingress-nginx ingress-nginx-controller | egrep -n 'Type:|LoadBalancer|EXTERNAL-IP|Events'
```
- **k8s:** svc 조회/describe
- **Linux:** `grep/egrep`

### 4-4. 실제 접속 테스트(curl) + Host 기반 라우팅
```sh
ING_IP=<external-ip-or-nodeip>
curl -i -H "Host: example.com" "http://$ING_IP/" | head -n 30
```
- **Linux:** `curl/head`

> Ingress는 **Host 헤더 기반 라우팅**이 흔합니다. 그래서 `-H "Host: ..."` 테스트가 중요합니다.

### 4-5. TLS/인증서(secret) 확인
```sh
kubectl get secret -n demo | grep tls
kubectl describe secret -n demo my-tls | egrep -n 'Type:|tls.crt|tls.key'
```
- **k8s:** secret 조회/describe
- **Linux:** `grep/egrep`

### 4-6. 경로 매칭 꼬임(우선순위/정규식/리라이트) 의심 시
```sh
kubectl get ingress -n demo my-ing -o yaml | egrep -n 'path:|pathType:|rewrite|annotation|backend'
```
- **k8s:** `get ... -o yaml`
- **Linux:** `egrep` (텍스트 탐색)

---

## 한 장 요약: “어디서 실행되는 Linux냐”가 핵심

- `kubectl ...` = **k8s API 대상으로 리소스 조작/조회**
- `| grep/awk/sed/sort/head/tail` = **내 쉘이 k8s 출력 텍스트를 가공**
- `kubectl exec POD -- <cmd>` = `<cmd>`는 **Linux지만 Pod 내부에서 실행**


---
# 이후 학습은 https://github.com/edumgt/kubernetes-fundamentals-edumgt 연습 후 7 장으로 넘어 갑니다.
---